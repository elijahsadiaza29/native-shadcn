{
  "name": "native-shadcn",
  "components": [
    {
      "name": "chart",
      "dependencies": [
        "react-native-gifted-charts",
        "gifted-charts-core",
        "react-native-svg",
        "expo-linear-gradient",
        "lucide-react-native"
      ],
      "files": [
        {
          "name": "chart.tsx",
          "content": "import * as React from 'react';\r\nimport { View, Text, type ViewStyle, type LayoutChangeEvent } from 'react-native';\r\nimport { useColorScheme } from 'nativewind';\r\nimport { cn } from '@/lib/utils';\r\n\r\nexport type ChartConfig = {\r\n  [key: string]: {\r\n    label?: React.ReactNode;\r\n    icon?: React.ComponentType;\r\n    color?: string;\r\n    theme?: {\r\n      light?: string;\r\n      dark?: string;\r\n    };\r\n  };\r\n};\r\n\r\ntype ChartContextProps = {\r\n  config: ChartConfig;\r\n  width: number;\r\n};\r\n\r\nconst ChartContext = React.createContext<ChartContextProps | null>(null);\r\n\r\nexport function useChart() {\r\n  const context = React.useContext(ChartContext);\r\n  if (!context) {\r\n    throw new Error('useChart must be used within a ChartContainer');\r\n  }\r\n  return context;\r\n}\r\n\r\nexport function ChartContainer({\r\n  id,\r\n  config,\r\n  children,\r\n  className,\r\n  style,\r\n}: {\r\n  id?: string;\r\n  config: ChartConfig;\r\n  children: React.ReactNode;\r\n  className?: string;\r\n  style?: ViewStyle;\r\n}) {\r\n  const { colorScheme } = useColorScheme();\r\n  const [containerWidth, setContainerWidth] = React.useState(0);\r\n\r\n  const handleLayout = React.useCallback((event: LayoutChangeEvent) => {\r\n    const { width } = event.nativeEvent.layout;\r\n    setContainerWidth(width);\r\n  }, []);\r\n\r\n  const chartConfig = React.useMemo(() => {\r\n    const resolvedConfig: ChartConfig = {};\r\n    Object.entries(config).forEach(([key, value]) => {\r\n      let color = value.color;\r\n      if (value.theme) {\r\n        color = colorScheme === 'dark' ? value.theme.dark : value.theme.light;\r\n      }\r\n      resolvedConfig[key] = { ...value, color };\r\n    });\r\n    return resolvedConfig;\r\n  }, [config, colorScheme]);\r\n\r\n\r\n  const responsiveChildren = React.useMemo(() => {\r\n    if (containerWidth === 0) return null;\r\n\r\n    return React.Children.map(children, (child) => {\r\n      if (!React.isValidElement(child)) return child;\r\n\r\n      const childProps = child.props as Record<string, any>;\r\n      const data: any[] | undefined = childProps.data;\r\n\r\n      if (!data?.length || childProps.donut !== undefined || childProps.radius !== undefined) {\r\n        return child;\r\n      }\r\n\r\n      const yAxisLabelWidth = childProps.yAxisLabelWidth ?? 40;\r\n      const chartWidth = Math.max(containerWidth - yAxisLabelWidth, 0);\r\n      const origBarWidth = childProps.barWidth ?? 0;\r\n      const isBarChart = origBarWidth > 0;\r\n\r\n      const overrides: Record<string, any> = {\r\n        width: chartWidth,\r\n        initialSpacing: 0,\r\n        endSpacing: 0,\r\n        disableScroll: true,\r\n      };\r\n\r\n      if (isBarChart) {\r\n        // Gap scales with bar count (20% of slot, max 6px) so bars stay\r\n        // visible even with 30+ data points.\r\n        const slotWidth = chartWidth / data.length;\r\n        const gap = Math.min(6, Math.max(Math.floor(slotWidth * 0.2), 1));\r\n        const barWidth = Math.max(Math.floor(slotWidth - gap), 1);\r\n\r\n        overrides.barWidth = barWidth;\r\n        overrides.spacing = gap;\r\n      } else {\r\n        // Line/Area charts: total â‰ˆ (n - 1) * spacing\r\n        const divisor = Math.max(data.length - 1, 1);\r\n        overrides.spacing = Math.max(chartWidth / divisor, 2);\r\n      }\r\n\r\n      return React.cloneElement(child as React.ReactElement<any>, overrides);\r\n    });\r\n  }, [children, containerWidth]);\r\n\r\n  // Determine if we should center align the chart (Pie/Radial charts)\r\n  const isCentered = React.useMemo(() => {\r\n    let centered = false;\r\n    React.Children.forEach(children, (child) => {\r\n      if (React.isValidElement(child)) {\r\n        const props = child.props as Record<string, any>;\r\n        if (props.donut !== undefined || props.radius !== undefined) {\r\n          centered = true;\r\n        }\r\n      }\r\n    });\r\n    return centered;\r\n  }, [children]);\r\n\r\n  return (\r\n    <ChartContext.Provider value={{ config: chartConfig, width: containerWidth }}>\r\n      <View\r\n        id={id}\r\n        onLayout={handleLayout}\r\n        style={[{ width: '100%', alignItems: isCentered ? 'center' : 'stretch' }, style]}>\r\n        {responsiveChildren}\r\n      </View>\r\n    </ChartContext.Provider>\r\n  );\r\n}\r\n\r\nexport function ChartLegend({ className, style }: { className?: string; style?: any }) {\r\n  const { config } = useChart();\r\n\r\n  if (!config) return null;\r\n\r\n  return (\r\n    <View\r\n      className={cn('mt-4 flex flex-row flex-wrap items-center justify-center gap-4', className)}\r\n      style={style}>\r\n      {Object.entries(config).map(([key, item]) => {\r\n        if (!item.label) return null;\r\n        return (\r\n          <View key={key} className=\"flex flex-row items-center gap-1.5\">\r\n            <View\r\n              style={{\r\n                width: 12,\r\n                height: 12,\r\n                borderRadius: 2,\r\n                backgroundColor: item.color || '#000',\r\n              }}\r\n            />\r\n            <Text className=\"text-sm text-muted-foreground\">{item.label}</Text>\r\n          </View>\r\n        );\r\n      })}\r\n    </View>\r\n  );\r\n}\r\n\r\nexport function ChartTooltip({\r\n  active,\r\n  payload,\r\n  label,\r\n  indicator = 'dot',\r\n  hideLabel = false,\r\n  hideIndicator = false,\r\n}: any) {\r\n  const { config } = useChart();\r\n\r\n  if (!active || !payload?.length) {\r\n    return null;\r\n  }\r\n\r\n  // gifted-charts sometimes passes a single object instead of an array\r\n  const items = Array.isArray(payload) ? payload : [payload];\r\n  const tooltipLabel = label || items[0]?.label;\r\n\r\n  return (\r\n    <View className=\"min-w-[130px] rounded-xl border border-border bg-card px-3 py-2 shadow-sm\">\r\n      {!hideLabel && tooltipLabel ? (\r\n        <Text className=\"mb-2 text-sm font-medium text-foreground\">{tooltipLabel}</Text>\r\n      ) : null}\r\n      <View className=\"flex flex-col gap-1.5\">\r\n        {items.map((item: any, index: number) => {\r\n          const configKeys = Object.keys(config);\r\n          // If the item doesn't explicitly have a `dataKey`, try to match it by index,\r\n          // or fallback to the first config key if it's a single-series chart.\r\n          const key =\r\n            item.dataKey || item.name || configKeys[Math.min(index, configKeys.length - 1)];\r\n          const conf = config[key];\r\n\r\n          if (!conf) return null;\r\n\r\n          const itemColor = item.color || item.frontColor || conf.color || '#000';\r\n\r\n          return (\r\n            <View key={index} className=\"flex flex-row items-center justify-between gap-4\">\r\n              <View className=\"flex flex-row items-center gap-2\">\r\n                {!hideIndicator && (\r\n                  <View\r\n                    style={{\r\n                      width: indicator === 'dot' ? 8 : 4,\r\n                      height: indicator === 'dot' ? 8 : 12,\r\n                      borderRadius: indicator === 'dot' ? 4 : 2,\r\n                      backgroundColor: itemColor,\r\n                    }}\r\n                  />\r\n                )}\r\n                <Text className=\"text-sm text-muted-foreground\">{conf.label || key}</Text>\r\n              </View>\r\n              <Text className=\"font-mono text-sm font-bold text-foreground\">{item.value}</Text>\r\n            </View>\r\n          );\r\n        })}\r\n      </View>\r\n    </View>\r\n  );\r\n}\r\n\r\n\r\nexport function getChartColor(key: string, config: ChartConfig): string {\r\n  return config[key]?.color || '#000';\r\n}\r\n\r\nexport function useChartTheme() {\r\n  const { colorScheme } = useColorScheme();\r\n  const isDark = colorScheme === 'dark';\r\n\r\n  return {\r\n    border: isDark ? 'hsl(0 0% 14.9%)' : 'hsl(0 0% 89.8%)',\r\n    input: isDark ? 'hsl(0 0% 14.9%)' : 'hsl(0 0% 89.8%)',\r\n    ring: isDark ? 'hsl(0 0% 83.1%)' : 'hsl(0 0% 3.9%)',\r\n    background: isDark ? 'hsl(0 0% 3.9%)' : 'hsl(0 0% 100%)',\r\n    foreground: isDark ? 'hsl(0 0% 98%)' : 'hsl(0 0% 3.9%)',\r\n    primary: isDark ? 'hsl(0 0% 98%)' : 'hsl(0 0% 9%)',\r\n    secondary: isDark ? 'hsl(0 0% 14.9%)' : 'hsl(0 0% 96.1%)',\r\n    muted: isDark ? 'hsl(0 0% 14.9%)' : 'hsl(0 0% 96.1%)',\r\n    mutedForeground: isDark ? 'hsl(0 0% 63.9%)' : 'hsl(0 0% 45.1%)',\r\n    accent: isDark ? 'hsl(0 0% 14.9%)' : 'hsl(0 0% 96.1%)',\r\n    destructive: isDark ? 'hsl(0 62.8% 30.6%)' : 'hsl(0 84.2% 60.2%)',\r\n  };\r\n}\r\n"
        }
      ]
    },
    {
      "name": "sonner",
      "dependencies": [
        "sonner-native",
        "lucide-react-native"
      ],
      "files": [
        {
          "name": "sonner.tsx",
          "content": "import React, { useRef, useEffect } from \"react\";\r\nimport { Toaster as SonnerToaster, toast } from \"sonner-native\";\r\nimport { useColorScheme } from \"nativewind\";\r\nimport { Platform } from \"react-native\";\r\nimport {\r\n  CheckCircle2,\r\n  AlertCircle,\r\n  AlertTriangle,\r\n  Info,\r\n  Loader2,\r\n} from \"lucide-react-native\";\r\nimport { Animated, Easing } from \"react-native\";\r\n\r\ntype ToasterProps = React.ComponentPropsWithoutRef<typeof SonnerToaster>;\r\n\r\nfunction Toaster({ ...props }: ToasterProps) {\r\n  const { colorScheme } = useColorScheme();\r\n  const isDark = colorScheme === \"dark\";\r\n\r\n  return (\r\n    <SonnerToaster\r\n      theme={colorScheme as \"light\" | \"dark\"}\r\n      richColors\r\n      closeButton\r\n      icons={{\r\n        success: <CheckCircle2 size={20} color=\"hsl(142.1 76.2% 36.3%)\" />,\r\n        error: <AlertCircle size={20} color=\"hsl(346.8 77.2% 49.8%)\" />,\r\n        warning: <AlertTriangle size={20} color=\"hsl(47.9 95.8% 53.1%)\" />,\r\n        info: <Info size={20} color=\"hsl(221.2 83.2% 53.3%)\" />,\r\n        loading: (\r\n          <SpinningLoader\r\n            size={20}\r\n            color={isDark ? \"hsl(0 0% 98%)\" : \"hsl(240 5.9% 10%)\"}\r\n          />\r\n        ),\r\n      }}\r\n      toastOptions={{\r\n        style: {\r\n          width: Platform.select({ web: 400 }),\r\n          maxWidth: \"100%\",\r\n        },\r\n      }}\r\n      {...props}\r\n    />\r\n  );\r\n}\r\n\r\nexport { Toaster, toast };\r\n\r\nfunction SpinningLoader({ size, color }: { size: number; color: string }) {\r\n  const spinAnim = useRef(new Animated.Value(0)).current;\r\n\r\n  useEffect(() => {\r\n    Animated.loop(\r\n      Animated.timing(spinAnim, {\r\n        toValue: 1,\r\n        duration: 1000,\r\n        easing: Easing.linear,\r\n        useNativeDriver: true,\r\n      }),\r\n    ).start();\r\n  }, [spinAnim]);\r\n\r\n  const spin = spinAnim.interpolate({\r\n    inputRange: [0, 1],\r\n    outputRange: [\"0deg\", \"360deg\"],\r\n  });\r\n\r\n  return (\r\n    <Animated.View style={{ transform: [{ rotate: spin }] }}>\r\n      <Loader2 size={size} color={color} />\r\n    </Animated.View>\r\n  );\r\n}\r\n"
        }
      ]
    },
    {
      "name": "drawer",
      "dependencies": [
        "@gorhom/bottom-sheet",
        "react-native-reanimated",
        "react-native-gesture-handler",
        "@rn-primitives/slot",
        "@rn-primitives/portal"
      ],
      "files": [
        {
          "name": "drawer.tsx",
          "content": "import * as React from 'react';\r\nimport { Platform, Pressable, View } from 'react-native';\r\nimport {\r\n  BottomSheetModal,\r\n  BottomSheetBackdrop,\r\n  type BottomSheetModalProps,\r\n  type BottomSheetBackdropProps,\r\n} from '@gorhom/bottom-sheet';\r\nimport { useColorScheme } from 'nativewind';\r\nimport { Text } from '@/components/ui/text';\r\nimport { cn } from '@/lib/utils';\r\nimport * as Slot from '@rn-primitives/slot';\r\nimport { Portal } from '@rn-primitives/portal';\r\n\r\nconst DrawerContext = React.createContext<{\r\n  open: boolean;\r\n  setOpen: (open: boolean) => void;\r\n  openDrawer: () => void;\r\n  closeDrawer: () => void;\r\n}>({\r\n  open: false,\r\n  setOpen: () => {},\r\n  openDrawer: () => {},\r\n  closeDrawer: () => {},\r\n});\r\n\r\nexport function Drawer({\r\n  children,\r\n  open: controlledOpen,\r\n  onOpenChange,\r\n}: {\r\n  children: React.ReactNode;\r\n  open?: boolean;\r\n  onOpenChange?: (open: boolean) => void;\r\n}) {\r\n  const [uncontrolledOpen, setUncontrolledOpen] = React.useState(false);\r\n\r\n  const open = controlledOpen ?? uncontrolledOpen;\r\n  const setOpen = React.useCallback(\r\n    (value: boolean) => {\r\n      setUncontrolledOpen(value);\r\n      onOpenChange?.(value);\r\n    },\r\n    [onOpenChange]\r\n  );\r\n\r\n  const openDrawer = React.useCallback(() => setOpen(true), [setOpen]);\r\n  const closeDrawer = React.useCallback(() => setOpen(false), [setOpen]);\r\n\r\n  return (\r\n    <DrawerContext.Provider value={{ open, setOpen, openDrawer, closeDrawer }}>\r\n      {children}\r\n    </DrawerContext.Provider>\r\n  );\r\n}\r\n\r\nexport const DrawerTrigger = React.forwardRef<\r\n  React.ElementRef<typeof Pressable>,\r\n  React.ComponentPropsWithoutRef<typeof Pressable> & { asChild?: boolean }\r\n>(({ asChild, onPress, ...props }, ref) => {\r\n  const { openDrawer } = React.useContext(DrawerContext);\r\n\r\n  const handlePress = (e: any) => {\r\n    console.log('[DrawerTrigger] Tapped! Opening drawer...');\r\n    openDrawer();\r\n    onPress?.(e);\r\n  };\r\n\r\n  if (asChild) {\r\n    return <Slot.Pressable ref={ref} onPress={handlePress} {...props} />;\r\n  }\r\n\r\n  return <Pressable ref={ref} onPress={handlePress} {...props} />;\r\n});\r\nDrawerTrigger.displayName = 'DrawerTrigger';\r\n\r\nexport const DrawerContent = React.forwardRef<\r\n  React.ElementRef<typeof BottomSheetModal>,\r\n  Omit<BottomSheetModalProps, 'ref' | 'snapPoints'> & {\r\n    children: React.ReactNode;\r\n    snapPoints?: string[] | number[];\r\n  }\r\n>(({ children, snapPoints, ...props }, ref) => {\r\n  const { open, closeDrawer } = React.useContext(DrawerContext);\r\n  const internalRef = React.useRef<BottomSheetModal>(null);\r\n  const { colorScheme } = useColorScheme();\r\n  const isDark = colorScheme === 'dark';\r\n\r\n  const defaultSnapPoints = React.useMemo(() => ['50%'], []);\r\n  const memoizedSnapPoints = React.useMemo(\r\n    () => snapPoints || defaultSnapPoints,\r\n    [snapPoints, defaultSnapPoints]\r\n  );\r\n\r\n  React.useEffect(() => {\r\n    console.log(\r\n      '[DrawerContent] open state changed:',\r\n      open,\r\n      'modal ref exists:',\r\n      !!internalRef.current\r\n    );\r\n    if (open) {\r\n      internalRef.current?.present();\r\n    } else {\r\n      internalRef.current?.dismiss();\r\n    }\r\n  }, [open]);\r\n\r\n  const handleDismiss = React.useCallback(() => {\r\n    closeDrawer();\r\n  }, [closeDrawer]);\r\n\r\n  const renderBackdrop = React.useCallback(\r\n    (backdropProps: BottomSheetBackdropProps) => (\r\n      <BottomSheetBackdrop {...backdropProps} disappearsOnIndex={-1} appearsOnIndex={0} />\r\n    ),\r\n    []\r\n  );\r\n\r\n  return (\r\n    <Portal name=\"bottom-sheet\">\r\n      <BottomSheetModal\r\n        ref={(node) => {\r\n          internalRef.current = node as any;\r\n          if (typeof ref === 'function') ref(node);\r\n          else if (ref) (ref as any).current = node;\r\n        }}\r\n        index={0}\r\n        snapPoints={memoizedSnapPoints}\r\n        enableDynamicSizing={false}\r\n        onDismiss={handleDismiss}\r\n        backdropComponent={renderBackdrop}\r\n        {...(Platform.OS === 'web'\r\n          ? {\r\n              backgroundComponent: ({ style }: any) => (\r\n                <View\r\n                  style={style}\r\n                  className=\"rounded-t-[10px] border-t border-border bg-background shadow-lg\"\r\n                />\r\n              ),\r\n              handleComponent: () => (\r\n                <View className=\"h-8 w-full items-center justify-center rounded-t-[10px]\">\r\n                  <View className=\"mt-2 h-1.5 w-12 rounded-full bg-muted-foreground/30\" />\r\n                </View>\r\n              ),\r\n            }\r\n          : {\r\n              backgroundStyle: [\r\n                {\r\n                  backgroundColor: isDark ? 'hsl(240 10% 3.9%)' : 'hsl(0 0% 100%)', // matching bg-background\r\n                },\r\n                props.backgroundStyle,\r\n              ],\r\n              handleIndicatorStyle: [\r\n                {\r\n                  backgroundColor: isDark ? 'hsl(240 3.7% 15.9%)' : 'hsl(240 5.9% 90%)', // matching bg-muted\r\n                  width: 50,\r\n                },\r\n                props.handleIndicatorStyle,\r\n              ],\r\n            })}\r\n        keyboardBlurBehavior=\"restore\"\r\n        {...props}>\r\n        <View className={cn('flex-1 bg-background', isDark ? 'dark' : '')}>{children}</View>\r\n      </BottomSheetModal>\r\n    </Portal>\r\n  );\r\n});\r\nDrawerContent.displayName = 'DrawerContent';\r\n\r\nexport function DrawerHeader({ className, ...props }: React.ComponentPropsWithoutRef<typeof View>) {\r\n  return <View className={cn('gap-1.5 p-4 text-center sm:text-left', className)} {...props} />;\r\n}\r\nDrawerHeader.displayName = 'DrawerHeader';\r\n\r\nexport function DrawerFooter({ className, ...props }: React.ComponentPropsWithoutRef<typeof View>) {\r\n  return <View className={cn('mt-auto gap-2 p-4', className)} {...props} />;\r\n}\r\nDrawerFooter.displayName = 'DrawerFooter';\r\n\r\nexport const DrawerTitle = React.forwardRef<\r\n  React.ElementRef<typeof Text>,\r\n  React.ComponentPropsWithoutRef<typeof Text>\r\n>(({ className, ...props }, ref) => (\r\n  <Text\r\n    ref={ref}\r\n    className={cn('text-lg font-semibold leading-none tracking-tight text-foreground', className)}\r\n    {...props}\r\n  />\r\n));\r\nDrawerTitle.displayName = 'DrawerTitle';\r\n\r\nexport const DrawerDescription = React.forwardRef<\r\n  React.ElementRef<typeof Text>,\r\n  React.ComponentPropsWithoutRef<typeof Text>\r\n>(({ className, ...props }, ref) => (\r\n  <Text ref={ref} className={cn('text-sm text-muted-foreground', className)} {...props} />\r\n));\r\nDrawerDescription.displayName = 'DrawerDescription';\r\n\r\nexport const DrawerClose = React.forwardRef<\r\n  React.ElementRef<typeof Pressable>,\r\n  React.ComponentPropsWithoutRef<typeof Pressable> & { asChild?: boolean }\r\n>(({ asChild, onPress, ...props }, ref) => {\r\n  const { closeDrawer } = React.useContext(DrawerContext);\r\n\r\n  const handlePress = (e: any) => {\r\n    closeDrawer();\r\n    onPress?.(e);\r\n  };\r\n\r\n  if (asChild) {\r\n    return <Slot.Pressable ref={ref} onPress={handlePress} {...props} />;\r\n  }\r\n\r\n  return <Pressable ref={ref} onPress={handlePress} {...props} />;\r\n});\r\nDrawerClose.displayName = 'DrawerClose';\r\n"
        }
      ]
    }
  ]
}